#!/usr/bin/env node

/**
 * Build script for AssemblyScript routines.
 *
 * Compiles *.ts files in src/routines/ to WASM and generates
 * a TypeScript module with base64-encoded WASM for each routine.
 *
 * Usage: node scripts/build-routines.mjs
 */

import { execSync } from "child_process";
import { readFileSync, writeFileSync, readdirSync } from "fs";
import { join, basename } from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, "..");

const ROUTINES_DIR = join(projectRoot, "src/routines");
const OUTPUT_DIR = join(projectRoot, "src/backend/wasm/generated");
const OUTPUT_FILE = join(OUTPUT_DIR, "routines.ts");

// Compile options for AssemblyScript
const ASC_OPTIONS = [
  "--runtime stub", // Minimal runtime, no GC
  "--optimize", // Enable optimization
  "--importMemory", // Import memory from host
  "--noAssert", // Remove assertions for smaller size
].join(" ");

async function main() {
  console.log("Building AssemblyScript routines...\n");

  // Find all .ts files in routines dir (excluding .test.ts and tsconfig.json)
  const files = readdirSync(ROUTINES_DIR).filter(
    (f) =>
      f.endsWith(".ts") && !f.endsWith(".test.ts") && f !== "tsconfig.json",
  );

  if (files.length === 0) {
    console.log("No routine files found in", ROUTINES_DIR);
    return;
  }

  /** @type {Record<string, string>} */
  const modules = {};

  for (const file of files) {
    const name = basename(file, ".ts");
    const inputPath = join(ROUTINES_DIR, file);
    const wasmPath = join(projectRoot, "tmp", `${name}.wasm`);

    console.log(`Compiling ${file}...`);

    try {
      // Compile to WASM
      execSync(`npx asc "${inputPath}" -o "${wasmPath}" ${ASC_OPTIONS}`, {
        cwd: projectRoot,
        stdio: "pipe",
      });

      // Read and base64 encode
      const wasmBytes = readFileSync(wasmPath);
      const base64 = wasmBytes.toString("base64");
      modules[name] = base64;

      console.log(`  ✓ ${name}: ${wasmBytes.length} bytes`);
    } catch (error) {
      console.error(`  ✗ Failed to compile ${file}:`, error.stderr?.toString());
      process.exit(1);
    }
  }

  // Generate TypeScript output
  const output = generateOutput(modules);

  // Ensure output directory exists
  execSync(`mkdir -p "${OUTPUT_DIR}"`, { cwd: projectRoot });

  writeFileSync(OUTPUT_FILE, output);

  // Format the generated file
  try {
    execSync(`npx prettier --write "${OUTPUT_FILE}"`, {
      cwd: projectRoot,
      stdio: "pipe",
    });
  } catch {
    // Prettier not available, skip formatting
  }

  console.log(`\nGenerated ${OUTPUT_FILE}`);
}

/**
 * Convert filename to valid JS identifier (replace hyphens with underscores)
 * @param {string} name
 * @returns {string}
 */
function toIdentifier(name) {
  return name.replace(/-/g, "_");
}

/**
 * @param {Record<string, string>} modules
 * @returns {string}
 */
function generateOutput(modules) {
  const entries = Object.entries(modules);

  return `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by scripts/build-routines.mjs from AssemblyScript sources.
 * Source files: src/routines/*.ts
 *
 * To regenerate: pnpm build:routines
 */

${entries
  .map(
    ([
      name,
      b64,
    ]) => `/** ${name} routine compiled from src/routines/${name}.ts */
export const ${toIdentifier(name).toUpperCase()}_WASM = "${b64}";
`,
  )
  .join("\n")}

/** Decode base64 to Uint8Array */
function base64ToBytes(base64: string): Uint8Array<ArrayBuffer> {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes as Uint8Array<ArrayBuffer>;
}

/** Compiled routine modules, lazily instantiated */
const moduleCache = new Map<string, WebAssembly.Module>();

/**
 * Get a compiled WebAssembly module for a routine.
 * Caches the compiled module for reuse.
 */
export async function getRoutineModule(name: string): Promise<WebAssembly.Module> {
  if (moduleCache.has(name)) {
    return moduleCache.get(name)!;
  }

  let wasm: string;
  switch (name) {
${entries.map(([name]) => `    case "${name}": wasm = ${toIdentifier(name).toUpperCase()}_WASM; break;`).join("\n")}
    default:
      throw new Error(\`Unknown routine: \${name}\`);
  }

  const bytes = base64ToBytes(wasm);
  const module = await WebAssembly.compile(bytes);
  moduleCache.set(name, module);
  return module;
}

/**
 * Get a compiled WebAssembly module synchronously.
 * Useful when async is not available.
 */
export function getRoutineModuleSync(name: string): WebAssembly.Module {
  if (moduleCache.has(name)) {
    return moduleCache.get(name)!;
  }

  let wasm: string;
  switch (name) {
${entries.map(([name]) => `    case "${name}": wasm = ${toIdentifier(name).toUpperCase()}_WASM; break;`).join("\n")}
    default:
      throw new Error(\`Unknown routine: \${name}\`);
  }

  const bytes = base64ToBytes(wasm);
  const module = new WebAssembly.Module(bytes);
  moduleCache.set(name, module);
  return module;
}
`;
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
